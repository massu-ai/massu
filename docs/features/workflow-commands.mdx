---
title: "Workflow Commands"
description: "28 slash commands for structured, verification-first AI-assisted development"
order: 13
---

# Workflow Commands

Massu AI's workflow commands are the command-line interface to its governance layer. These 28 slash commands enforce a structured, verification-first approach across the full development lifecycle -- from writing a plan to pushing code. Each command is a mandatory execution protocol, not a suggestion: when a command says "loop until complete," it loops until complete.

## Why This Matters

Unstructured AI development produces unstructured results:

- Plans written from memory get skipped or forgotten
- Implementations claim completion without running a single verification
- Commits include type errors, failing tests, and orphaned references
- "100% complete" turns out to mean "I think it's mostly done"
- Security and dependency issues are caught by CI, not the developer

The workflow commands eliminate these failure modes by requiring proof at every stage. Verification output is shown inline, not assumed. All items in a plan are executed, not most of them.

## Implementation Workflow

The core pipeline for structured feature development. Every non-trivial change should flow through all five stages in order. Two additional commands handle scaffolding and fast pre-push verification.

```
/massu-create-plan  -->  /massu-plan  -->  /massu-loop  -->  /massu-commit  -->  /massu-push
   (create)             (audit)          (implement)       (pre-commit)        (pre-push)
```

### `/massu-create-plan`

Creates a plan document from requirements and saves it to `docs/plans/`. The plan includes specific deliverables with file paths, implementation steps, and verification requirements for each item. Use this before any non-trivial change so that scope is defined before a single line of code is written.

See [/massu-create-plan](/docs/commands/massu-create-plan) for full documentation.

### `/massu-plan`

Audits an existing plan document for completeness, gaps, and missing verifications -- without editing source code. It checks that every deliverable has a verification type, that blast radius analysis is included for value changes, and that the plan is granular enough to implement without ambiguity. Run this after creating a plan and before starting implementation.

See [/massu-plan](/docs/commands/massu-plan) for full documentation.

### `/massu-loop`

The implementation engine. It reads the plan file from disk, executes each deliverable with mandatory verification, shows the verification command and its output as proof, and loops until every item is complete. Stopping at "most items" is a protocol violation -- the loop continues until all deliverables are verified.

See [/massu-loop](/docs/commands/massu-loop) for full documentation.

### `/massu-commit`

A pre-commit verification gate that runs 7 checks before allowing a commit: type safety, all tests passing, build success, pattern compliance, no debug code, no exposed secrets, and no orphaned references from removals. It fixes minor issues automatically and blocks on anything that requires human attention.

See [/massu-commit](/docs/commands/massu-commit) for full documentation.

### `/massu-push`

The final verification gate before pushing to remote. Runs the full verification suite including type check, tests, build, security scan, and dependency audit. Designed to catch everything that should not reach CI before it does.

See [/massu-push](/docs/commands/massu-push) for full documentation.

### `/massu-push-light`

Fast pre-push verification that completes in approximately 90 seconds. It runs the most critical subset of verification checks -- type safety, tests, and build -- without the full security scan and dependency audit. Use it for low-risk pushes where speed matters and a full `/massu-push` is not warranted.

See [/massu-push-light](/docs/commands/massu-push-light) for full documentation.

### `/massu-new-feature`

Feature scaffolding with correct patterns pre-applied. It generates the initial file structure for a new feature -- tool module, test file, type definitions, and config entries -- following the project's established conventions. Use it instead of manually creating files when adding a new capability, so that registration, naming, and structure are correct from the start.

See [/massu-new-feature](/docs/commands/massu-new-feature) for full documentation.

## Development Tools

Four commands for day-to-day development tasks that require more than a one-shot prompt.

### `/massu-test`

Runs the test suite with failure analysis -- it does not just report which tests failed, it investigates why and generates fixes or new tests as needed. Use it when tests are failing and you want structured diagnosis rather than a raw error dump.

See [/massu-test](/docs/commands/massu-test) for full documentation.

### `/massu-debug`

Systematic debugging through hypothesis generation and testing. It forms explicit hypotheses about the root cause, tests each one with targeted evidence gathering, and eliminates possibilities methodically. Use it for bugs that are not immediately obvious from a stack trace.

See [/massu-debug](/docs/commands/massu-debug) for full documentation.

### `/massu-refactor`

Safe refactoring with behavioral equivalence verification. It plans the refactor, executes it, and verifies that observable behavior is unchanged by running tests before and after. Use it when restructuring code that has test coverage and cannot regress.

See [/massu-refactor](/docs/commands/massu-refactor) for full documentation.

### `/massu-hotfix`

A scoped quick-fix workflow for urgent production issues. It creates a branch, implements the minimal fix, runs targeted tests, commits with a structured message, and opens a PR. Use it for bugs that need to ship immediately without going through the full plan-loop cycle.

See [/massu-hotfix](/docs/commands/massu-hotfix) for full documentation.

## Quality & Verification

Four analysis commands for code quality. None of these edit source code.

### `/massu-review`

Automated code review across 7 dimensions: correctness, security, performance, maintainability, test coverage, API design, and rule compliance. It produces structured findings with severity levels and specific line references. Use it before requesting human review or as a pre-merge check.

See [/massu-review](/docs/commands/massu-review) for full documentation.

### `/massu-audit-deps`

Dependency audit covering known vulnerabilities (via npm audit), license compatibility, and unused packages. It surfaces transitive vulnerabilities and flags licenses that may conflict with your project's requirements. Use it before releases or when adding new dependencies.

See [/massu-audit-deps](/docs/commands/massu-audit-deps) for full documentation.

### `/massu-verify`

Runs all VR-* verification checks with proof output. It executes every verification requirement defined in the canonical rules -- VR-FILE, VR-GREP, VR-BUILD, VR-TYPE, VR-TEST, VR-NEGATIVE, and all others -- and produces a structured pass/fail report with the actual command output as evidence. Use it as a comprehensive verification gate or to audit the current state of all verification requirements.

See [/massu-verify](/docs/commands/massu-verify) for full documentation.

### `/massu-estimate`

Effort estimation with complexity scoring and historical comparison. Analyzes a task description or plan file to estimate hours or story points based on codebase impact, novelty, risk, and similar past tasks stored in memory. Use it before starting a task to surface scope disagreements early.

See [/massu-estimate](/docs/commands/massu-estimate) for full documentation.

## Release & Ops

Three commands for release preparation and operational tasks.

### `/massu-release`

Release preparation with full verification. It runs the complete verification suite, generates a changelog diff, checks that all planned items are complete, and prepares the release artifacts. Use it as the final gate before tagging a release.

See [/massu-release](/docs/commands/massu-release) for full documentation.

### `/massu-changelog`

Generates a structured changelog from git commits grouped by type (features, fixes, breaking changes). Writes to `CHANGELOG.md` only -- no source code changes. Use it as part of the release workflow or to update the changelog after a sprint.

See [/massu-changelog](/docs/commands/massu-changelog) for full documentation.

### `/massu-status`

A read-only project health dashboard that runs 14 checks across type safety, tests, build, security, dependencies, feature registry health, and recent audit activity. Produces a structured report with pass/fail status per check. Use it at the start of a session to understand the current state of the project.

See [/massu-status](/docs/commands/massu-status) for full documentation.

## Productivity

Six commands for codebase hygiene, documentation, and guided development workflows.

### `/massu-cleanup`

Systematically removes dead code -- unused imports, dead exports, orphaned files, and stale references. Performs blast radius analysis before every removal and verifies with negative grep after. Use it before a release or when the codebase has accumulated cruft from iterative development.

See [/massu-cleanup](/docs/commands/massu-cleanup) for full documentation.

### `/massu-doc-gen`

Generates JSDoc comments, README sections, and API reference documentation for undocumented exports. Analyzes function signatures and usage patterns to produce accurate descriptions. Use it to bootstrap documentation coverage or to keep API docs current before a release.

See [/massu-doc-gen](/docs/commands/massu-doc-gen) for full documentation.

### `/massu-golden-path`

Generates a golden-path guide for a feature or workflow -- a step-by-step description of the recommended approach including which tools to call, which commands to run, and which patterns to follow. Useful for onboarding, documenting architectural decisions, and ensuring consistent implementation across team members.

### `/massu-dead-code`

Audit-only dead code detection. Identifies unused exports, unreachable branches, and orphaned files without making any changes. Use it to understand the scope of cleanup work before running `/massu-cleanup`.

### `/massu-tdd`

Test-driven development scaffold. Writes failing tests first based on the specification, then implements code to make them pass, following the red-green-refactor cycle. Ensures test coverage is built in from the start rather than added after implementation.

### `/massu-guide`

Generates a step-by-step guide for a given task or feature. Unlike `/massu-golden-path` (which generates a recommended approach), `/massu-guide` produces documentation-style guidance for end users or other developers explaining how a feature works.

## Extended Verification

Four commands for browser-level, dependency, documentation, and parity verification.

### `/massu-verify-playwright`

Runs Playwright end-to-end verification for UI flows. Useful for verifying that AI-generated UI code actually works in a browser context. Generates a structured pass/fail report with screenshots on failure.

### `/massu-deps`

Dependency graph analysis and unused-dependency detection. Unlike `/massu-audit-deps` (which focuses on vulnerabilities and licenses), this command analyzes import relationships to find packages that are installed but never imported, and packages that are imported but not in `package.json`.

### `/massu-docs`

Documentation coverage and freshness audit. Identifies exported functions without JSDoc, public APIs without README documentation, and documentation that references deleted or renamed exports. Produces a structured coverage report without making any changes.

### `/massu-parity`

Feature parity check between two systems or branches. Given a source system and a target system, it identifies features present in the source that are missing from the target. Used when porting features between codebases or branches. See `/massu-internal-feature-parity` for the full parity workflow (internal command, private repo only).

## Internal Commands

The following commands are available only in the private repository. They provide deep audits and specialized tooling beyond the public release.

### `/massu-internal-infra-audit`

Infrastructure-layer audit covering environment variables, secrets management, deployment configuration, and infrastructure-as-code files. Checks for missing required env vars, hardcoded values that should be in config, and deployment configuration drift.

### `/massu-internal-ui-audit`

UI component audit covering accessibility (WCAG 2.1 AA), stale props, missing test coverage, and component API consistency. Produces a structured report per component with severity-ranked findings.

### `/massu-internal-type-mismatch-audit`

Type mismatch audit across module boundaries. Finds cases where a function's declared TypeScript type does not match how it is actually used at call sites, particularly across package boundaries where type inference may hide mismatches.

### `/massu-internal-db-audit`

Database schema and query audit. Identifies missing indexes, N+1 query patterns, tables without RLS policies, and foreign keys without cascades. Produces a prioritized remediation list.

## Command Decision Tree

Not sure which command to use? Start here:

- **Starting new work** -- `/massu-create-plan` then `/massu-plan` then `/massu-loop`
- **Scaffolding a feature** -- `/massu-new-feature`
- **Ready to commit** -- `/massu-commit`
- **Ready to push** -- `/massu-push` (full) or `/massu-push-light` (fast ~90s)
- **Tests are failing** -- `/massu-test`
- **Bug to diagnose** -- `/massu-debug`
- **Urgent production fix** -- `/massu-hotfix`
- **Restructuring code** -- `/massu-refactor`
- **Before a code review** -- `/massu-review`
- **Cutting a release** -- `/massu-release` (runs `/massu-changelog` internally)
- **Project health check** -- `/massu-status`
- **Dependency concerns** -- `/massu-audit-deps`
- **Dead code / cleanup** -- `/massu-cleanup` or `/massu-dead-code` (audit only)
- **Generate documentation** -- `/massu-doc-gen` or `/massu-docs` (audit only)
- **Effort estimation** -- `/massu-estimate`
- **Run all VR checks** -- `/massu-verify`
- **UI end-to-end verification** -- `/massu-verify-playwright`
- **Feature parity check** -- `/massu-parity`
- **Dependency analysis** -- `/massu-deps`
- **TDD workflow** -- `/massu-tdd`
- **Golden-path guidance** -- `/massu-golden-path`
- **Step-by-step guide** -- `/massu-guide`

## Tips

- Always run `/massu-plan` after `/massu-create-plan` -- the audit step catches gaps that are invisible when you wrote the plan yourself.
- `/massu-commit` and `/massu-push` are gates, not formalities. If they block, fix the issue rather than working around it.
- `/massu-status` at the start of each session takes 30 seconds and prevents surprises mid-implementation.
- The Implementation Workflow commands do not edit source code until `/massu-loop`. If you need to rethink the plan, do it before you reach the loop.
- `/massu-hotfix` is for genuine emergencies. For anything that can wait an hour, use the full plan-loop-commit-push pipeline.
- Use `/massu-push-light` for low-risk pushes when the full `/massu-push` suite is not warranted -- it runs in about 90 seconds.
