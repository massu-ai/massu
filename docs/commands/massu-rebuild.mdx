---
title: "/massu-rebuild"
description: "Safe rebuild and replacement protocol enforcing feature parity before deletion"
order: 38
---

# /massu-rebuild

A safe rebuild and replacement protocol that enforces 100% feature parity before allowing deletion of old code. It catalogs every feature in the old implementation, tracks parity through a living checklist, and gates deletion behind a verification pass.

## Usage

```
/massu-rebuild
```

The command will prompt for the module, tool, hook, or system being rebuilt.

## Workflow Steps

### Phase 0: Catalog Old Implementation
Reads the old code completely and creates an exhaustive feature catalog covering exports, types, tool definitions, handlers, config access, database operations, error handling, helpers, and constants. This step is mandatory before writing any new code.

### Phase 1: Parity Checklist
Builds a living comparison document mapping every old feature to its planned new location. Each item is tracked as PENDING, IN PROGRESS, DONE, or INTENTIONAL_REMOVAL (which requires documented justification).

### Phase 2: Implement New Version
Builds the replacement implementation while referencing the parity checklist at each step. Each feature is verified with grep proof as it is completed.

### Phase 3: Verify Parity (VR-PARITY Gate)
Runs a full parity audit that blocks deletion of old code:
- All parity items must be DONE or INTENTIONAL_REMOVAL
- Zero PENDING items remain
- Each DONE item has grep proof
- Build, type check, and tests must pass

### Phase 4: Delete Old Code
Deletion is permitted only after the VR-PARITY gate passes. Old files, imports, and references are removed, followed by a post-delete verification confirming zero dangling references and a clean build.

### Auto-Learning
After every rebuild, the system records the WRONG vs CORRECT pattern, optionally adds a pattern scanner check, and searches codebase-wide for similar issues.

## What It Does

- Prevents feature regression during module replacement
- Enforces a zero-gap audit loop where parity must reach 0 gaps in a single fresh pass
- Tracks intentional removals with explicit justification
- Gates all deletion behind verified parity
- Learns from each rebuild to prevent future regressions

## When to Use

- Replacing an existing module with a rewritten version
- Migrating a tool from one pattern to another (e.g., legacy 2-function to 3-function)
- Rebuilding a hook or system component from scratch
- Any time old code is being replaced rather than incrementally modified
