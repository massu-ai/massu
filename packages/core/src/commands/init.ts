// Copyright (c) 2026 Massu. All rights reserved.
// Licensed under BSL 1.1 - see LICENSE file for details.

/**
 * `massu init` â€” One-command full project setup.
 *
 * 1. Detects project framework (scans package.json)
 * 2. Generates massu.config.yaml (or preserves existing)
 * 3. Registers MCP server in .mcp.json (creates or merges)
 * 4. Installs all 11 hooks in .claude/settings.local.json
 * 5. Prints success summary
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { resolve, basename, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
import { stringify as yamlStringify } from 'yaml';

// ============================================================
// Types
// ============================================================

interface FrameworkDetection {
  type: string;
  router: string;
  orm: string;
  ui: string;
}

interface InitResult {
  configCreated: boolean;
  configSkipped: boolean;
  mcpRegistered: boolean;
  mcpSkipped: boolean;
  hooksInstalled: boolean;
  hooksCount: number;
  framework: FrameworkDetection;
}

// ============================================================
// Framework Auto-Detection
// ============================================================

export function detectFramework(projectRoot: string): FrameworkDetection {
  const result: FrameworkDetection = {
    type: 'javascript',
    router: 'none',
    orm: 'none',
    ui: 'none',
  };

  const pkgPath = resolve(projectRoot, 'package.json');
  if (!existsSync(pkgPath)) return result;

  try {
    const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
    const allDeps = {
      ...pkg.dependencies,
      ...pkg.devDependencies,
    };

    // Language detection
    if (allDeps['typescript']) result.type = 'typescript';

    // UI framework detection
    if (allDeps['next']) result.ui = 'nextjs';
    else if (allDeps['@sveltejs/kit']) result.ui = 'sveltekit';
    else if (allDeps['nuxt']) result.ui = 'nuxt';
    else if (allDeps['@angular/core']) result.ui = 'angular';
    else if (allDeps['vue']) result.ui = 'vue';
    else if (allDeps['react']) result.ui = 'react';

    // Router detection
    if (allDeps['@trpc/server']) result.router = 'trpc';
    else if (allDeps['graphql'] || allDeps['@apollo/server']) result.router = 'graphql';
    else if (allDeps['express'] || allDeps['fastify'] || allDeps['hono']) result.router = 'rest';

    // ORM detection
    if (allDeps['@prisma/client'] || allDeps['prisma']) result.orm = 'prisma';
    else if (allDeps['drizzle-orm']) result.orm = 'drizzle';
    else if (allDeps['typeorm']) result.orm = 'typeorm';
    else if (allDeps['sequelize']) result.orm = 'sequelize';
    else if (allDeps['mongoose']) result.orm = 'mongoose';
  } catch {
    // Best effort
  }

  return result;
}

// ============================================================
// Config File Generation
// ============================================================

export function generateConfig(projectRoot: string, framework: FrameworkDetection): boolean {
  const configPath = resolve(projectRoot, 'massu.config.yaml');

  if (existsSync(configPath)) {
    return false; // Config already exists
  }

  const projectName = basename(projectRoot);

  const config = {
    project: {
      name: projectName,
      root: 'auto',
    },
    framework: {
      type: framework.type,
      router: framework.router,
      orm: framework.orm,
      ui: framework.ui,
    },
    paths: {
      source: 'src',
      aliases: { '@': 'src' },
    },
    toolPrefix: 'massu',
    domains: [],
    rules: [
      {
        pattern: 'src/**/*.ts',
        rules: ['Use ESM imports, not CommonJS'],
      },
    ],
  };

  const yamlContent = `# Massu AI Configuration
# Generated by: npx massu init
# Documentation: https://massu.ai/docs/getting-started/configuration

${yamlStringify(config)}`;

  writeFileSync(configPath, yamlContent, 'utf-8');
  return true;
}

// ============================================================
// MCP Server Registration
// ============================================================

export function registerMcpServer(projectRoot: string): boolean {
  const mcpPath = resolve(projectRoot, '.mcp.json');

  let existing: Record<string, unknown> = {};
  if (existsSync(mcpPath)) {
    try {
      existing = JSON.parse(readFileSync(mcpPath, 'utf-8'));
    } catch {
      existing = {};
    }
  }

  // Check if already registered
  const servers = (existing.mcpServers ?? {}) as Record<string, unknown>;
  if (servers.massu) {
    return false; // Already registered
  }

  // Add massu server
  servers.massu = {
    type: 'stdio',
    command: 'npx',
    args: ['-y', '@massu/core'],
  };

  existing.mcpServers = servers;

  writeFileSync(mcpPath, JSON.stringify(existing, null, 2) + '\n', 'utf-8');
  return true;
}

// ============================================================
// Hook Installation
// ============================================================

interface HookEntry {
  type: 'command';
  command: string;
  timeout: number;
}

interface HookGroup {
  matcher?: string;
  hooks: HookEntry[];
}

type HooksConfig = Record<string, HookGroup[]>;

/**
 * Resolve the path to compiled hook files.
 * Handles both local development and npm-installed scenarios.
 */
export function resolveHooksDir(): string {
  // Try to find the hooks in node_modules first (installed via npm)
  const cwd = process.cwd();
  const nodeModulesPath = resolve(cwd, 'node_modules/@massu/core/dist/hooks');
  if (existsSync(nodeModulesPath)) {
    return 'node_modules/@massu/core/dist/hooks';
  }

  // Fall back to finding relative to this source file
  const localPath = resolve(__dirname, '../dist/hooks');
  if (existsSync(localPath)) {
    return localPath;
  }

  // Default to node_modules path (will be created on npm install)
  return 'node_modules/@massu/core/dist/hooks';
}

function hookCmd(hooksDir: string, hookFile: string): string {
  return `node ${hooksDir}/${hookFile}`;
}

export function buildHooksConfig(hooksDir: string): HooksConfig {
  return {
    SessionStart: [
      {
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'session-start.js'), timeout: 10 },
        ],
      },
    ],
    PreToolUse: [
      {
        matcher: 'Bash',
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'security-gate.js'), timeout: 5 },
        ],
      },
      {
        matcher: 'Bash|Write',
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'pre-delete-check.js'), timeout: 5 },
        ],
      },
    ],
    PostToolUse: [
      {
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'post-tool-use.js'), timeout: 10 },
          { type: 'command', command: hookCmd(hooksDir, 'quality-event.js'), timeout: 5 },
          { type: 'command', command: hookCmd(hooksDir, 'cost-tracker.js'), timeout: 5 },
        ],
      },
      {
        matcher: 'Edit|Write',
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'post-edit-context.js'), timeout: 5 },
        ],
      },
    ],
    Stop: [
      {
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'session-end.js'), timeout: 15 },
        ],
      },
    ],
    PreCompact: [
      {
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'pre-compact.js'), timeout: 10 },
        ],
      },
    ],
    UserPromptSubmit: [
      {
        hooks: [
          { type: 'command', command: hookCmd(hooksDir, 'user-prompt.js'), timeout: 5 },
          { type: 'command', command: hookCmd(hooksDir, 'intent-suggester.js'), timeout: 5 },
        ],
      },
    ],
  };
}

export function installHooks(projectRoot: string): { installed: boolean; count: number } {
  const claudeDir = resolve(projectRoot, '.claude');
  const settingsPath = resolve(claudeDir, 'settings.local.json');

  // Ensure .claude directory exists
  if (!existsSync(claudeDir)) {
    mkdirSync(claudeDir, { recursive: true });
  }

  // Read existing settings
  let settings: Record<string, unknown> = {};
  if (existsSync(settingsPath)) {
    try {
      settings = JSON.parse(readFileSync(settingsPath, 'utf-8'));
    } catch {
      settings = {};
    }
  }

  // Resolve hook paths
  const hooksDir = resolveHooksDir();

  // Build hooks config
  const hooksConfig = buildHooksConfig(hooksDir);

  // Count total hooks
  let hookCount = 0;
  for (const groups of Object.values(hooksConfig)) {
    for (const group of groups) {
      hookCount += group.hooks.length;
    }
  }

  // Merge hooks into settings (replace hooks section, preserve everything else)
  settings.hooks = hooksConfig;

  writeFileSync(settingsPath, JSON.stringify(settings, null, 2) + '\n', 'utf-8');

  return { installed: true, count: hookCount };
}

// ============================================================
// Main Init Flow
// ============================================================

export async function runInit(): Promise<void> {
  const projectRoot = process.cwd();

  console.log('');
  console.log('Massu AI - Project Setup');
  console.log('========================');
  console.log('');

  // Step 1: Detect framework
  const framework = detectFramework(projectRoot);
  const frameworkParts: string[] = [];
  if (framework.type !== 'javascript') frameworkParts.push(capitalize(framework.type));
  if (framework.ui !== 'none') frameworkParts.push(formatName(framework.ui));
  if (framework.orm !== 'none') frameworkParts.push(capitalize(framework.orm));
  if (framework.router !== 'none') frameworkParts.push(framework.router.toUpperCase());
  const detected = frameworkParts.length > 0 ? frameworkParts.join(', ') : 'JavaScript';
  console.log(`  Detected: ${detected}`);

  // Step 2: Create config
  const configCreated = generateConfig(projectRoot, framework);
  if (configCreated) {
    console.log('  Created massu.config.yaml');
  } else {
    console.log('  massu.config.yaml already exists (preserved)');
  }

  // Step 3: Register MCP server
  const mcpRegistered = registerMcpServer(projectRoot);
  if (mcpRegistered) {
    console.log('  Registered MCP server in .mcp.json');
  } else {
    console.log('  MCP server already registered in .mcp.json');
  }

  // Step 4: Install hooks
  const { count: hooksCount } = installHooks(projectRoot);
  console.log(`  Installed ${hooksCount} hooks in .claude/settings.local.json`);

  // Step 5: Databases info
  console.log('  Databases will auto-create on first session');

  // Summary
  console.log('');
  console.log('Massu AI is ready. Start a Claude Code session to begin.');
  console.log('');
  console.log('Next steps:');
  console.log('  claude                    # Start a session (hooks activate automatically)');
  console.log('  npx massu doctor          # Verify installation health');
  console.log('');
  console.log('Documentation: https://massu.ai/docs');
  console.log('');
}

// ============================================================
// Helpers
// ============================================================

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function formatName(name: string): string {
  const names: Record<string, string> = {
    nextjs: 'Next.js',
    sveltekit: 'SvelteKit',
    nuxt: 'Nuxt',
    angular: 'Angular',
    vue: 'Vue',
    react: 'React',
  };
  return names[name] ?? capitalize(name);
}
