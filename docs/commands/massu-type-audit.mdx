---
title: "/massu-type-audit"
description: "Comprehensive type mismatch audit across module boundaries, config types, and runtime type safety"
order: 42
---

# /massu-type-audit

A comprehensive type safety audit that goes beyond what the TypeScript compiler catches. It traces types across module boundaries, config values through runtime code, `as any` casts, database schema alignment, and serialization safety to find mismatches that cause runtime failures.

## Usage

```
/massu-type-audit
```

Optional scope argument to narrow the audit:

```
/massu-type-audit tools    # MCP tool handlers only
/massu-type-audit config   # Config-related types only
/massu-type-audit hooks    # Hook type contracts only
```

## What It Does

The audit runs eight sections, each targeting a different category of type mismatch:

### 1. MCP Tool Type Contracts
Verifies every tool's `inputSchema.properties` definition matches what the handler function actually destructures and uses. Catches mismatched property names and types.

### 2. Config Type Verification
Traces config values from their type definition in `config.ts` through `getConfig()` calls to tool handlers and responses. Ensures config property types match runtime expectations.

### 3. `as any` Cast Audit
Finds every `as any` cast in source code and categorizes it by risk:
- **P0 Structural mismatch** -- wrong shape, will crash at runtime
- **P1 Type narrowing** -- known safe but loses type safety
- **P2 Third-party interop** -- SDK gaps, acceptable with documentation
- **P3 Cosmetic** -- types match at runtime, cast can be removed

### 4. Database Type Verification
Compares SQLite column types in CREATE TABLE statements against the TypeScript types used when reading and writing to those tables.

### 5. Return Type and Serialization Audit
Checks that MCP tool return values can be safely serialized to JSON. Flags BigInt values, circular references, and undefined properties that would fail serialization.

### 6. Enum and Union Value Alignment
Verifies that enum and union type values are consistent across module boundaries. Catches cases where one module uses a value the other does not accept.

### 7. Function Signature Audit
Checks exported function signatures against their call sites for correct argument count, argument types, and return value usage.

### 8. Recurring Pattern Detection
Identifies systematic anti-patterns like `Record<string, any>`, `as unknown` chains, and type assertions that may hide structural mismatches across multiple files.

## Output

Produces a prioritized report with P0/P1/P2 issue counts per section, specific file:line locations, and recommended fixes. The audit loops until a clean pass finds zero new issues.

## When to Use

- After schema changes (new tables, column type modifications)
- After adding new MCP tools
- After modifying config types or the config interface
- Before major releases
- When debugging runtime type errors that TypeScript did not catch
