---
title: "Workflow Commands"
description: "43 slash commands for structured, verification-first AI-assisted development"
order: 13
---

# Workflow Commands

Massu AI's workflow commands are the command-line interface to its governance layer. These 43 slash commands enforce a structured, verification-first approach across the full development lifecycle -- from writing a plan to pushing code. Each command is a mandatory execution protocol, not a suggestion: when a command says "loop until complete," it loops until complete.

## Why This Matters

Unstructured AI development produces unstructured results:

- Plans written from memory get skipped or forgotten
- Implementations claim completion without running a single verification
- Commits include type errors, failing tests, and orphaned references
- "100% complete" turns out to mean "I think it's mostly done"
- Security and dependency issues are caught by CI, not the developer

The workflow commands eliminate these failure modes by requiring proof at every stage. Verification output is shown inline, not assumed. All items in a plan are executed, not most of them.

## Implementation Workflow

The core pipeline for structured feature development. Every non-trivial change should flow through all five stages in order. Three additional commands handle scaffolding, rebuilds, and rollbacks.

```
/massu-create-plan  -->  /massu-plan  -->  /massu-loop  -->  /massu-commit  -->  /massu-push
   (create)             (audit)          (implement)       (pre-commit)        (pre-push)
```

### `/massu-create-plan`

Creates a plan document from requirements and saves it to `docs/plans/`. The plan includes specific deliverables with file paths, implementation steps, and verification requirements for each item. Use this before any non-trivial change so that scope is defined before a single line of code is written.

See [/massu-create-plan](/docs/commands/massu-create-plan) for full documentation.

### `/massu-plan`

Audits an existing plan document for completeness, gaps, and missing verifications -- without editing source code. It checks that every deliverable has a verification type, that blast radius analysis is included for value changes, and that the plan is granular enough to implement without ambiguity. Run this after creating a plan and before starting implementation.

See [/massu-plan](/docs/commands/massu-plan) for full documentation.

### `/massu-loop`

The implementation engine. It reads the plan file from disk, executes each deliverable with mandatory verification, shows the verification command and its output as proof, and loops until every item is complete. Stopping at "most items" is a protocol violation -- the loop continues until all deliverables are verified.

See [/massu-loop](/docs/commands/massu-loop) for full documentation.

### `/massu-commit`

A pre-commit verification gate that runs 7 checks before allowing a commit: type safety, all tests passing, build success, pattern compliance, no debug code, no exposed secrets, and no orphaned references from removals. It fixes minor issues automatically and blocks on anything that requires human attention.

See [/massu-commit](/docs/commands/massu-commit) for full documentation.

### `/massu-push`

The final verification gate before pushing to remote. Runs the full verification suite including type check, tests, build, security scan, and dependency audit. Designed to catch everything that should not reach CI before it does.

See [/massu-push](/docs/commands/massu-push) for full documentation.

### `/massu-new-feature`

Feature scaffolding with correct patterns pre-applied. It generates the initial file structure for a new feature -- tool module, test file, type definitions, and config entries -- following the project's established conventions. Use it instead of manually creating files when adding a new capability, so that registration, naming, and structure are correct from the start.

See [/massu-new-feature](/docs/commands/massu-new-feature) for full documentation.

### `/massu-rebuild`

Safe rebuild and replacement protocol that enforces feature parity before deleting the old implementation. It inventories all behaviors of the existing module, builds the replacement with full coverage of those behaviors, verifies parity with tests, and only then removes the original. Use it when a module needs to be rewritten rather than refactored.

See [/massu-rebuild](/docs/commands/massu-rebuild) for full documentation.

### `/massu-rollback`

Safe rollback with state preservation and verification. It captures the current state before reverting, performs the rollback, and verifies that the target state is restored correctly -- including database migrations, config changes, and file removals. Use it when a recent change needs to be undone without losing diagnostic information about what went wrong.

See [/massu-rollback](/docs/commands/massu-rollback) for full documentation.

## Development Tools

Four commands for day-to-day development tasks that require more than a one-shot prompt.

### `/massu-test`

Runs the test suite with failure analysis -- it does not just report which tests failed, it investigates why and generates fixes or new tests as needed. Use it when tests are failing and you want structured diagnosis rather than a raw error dump.

See [/massu-test](/docs/commands/massu-test) for full documentation.

### `/massu-debug`

Systematic debugging through hypothesis generation and testing. It forms explicit hypotheses about the root cause, tests each one with targeted evidence gathering, and eliminates possibilities methodically. Use it for bugs that are not immediately obvious from a stack trace.

See [/massu-debug](/docs/commands/massu-debug) for full documentation.

### `/massu-refactor`

Safe refactoring with behavioral equivalence verification. It plans the refactor, executes it, and verifies that observable behavior is unchanged by running tests before and after. Use it when restructuring code that has test coverage and cannot regress.

See [/massu-refactor](/docs/commands/massu-refactor) for full documentation.

### `/massu-hotfix`

A scoped quick-fix workflow for urgent production issues. It creates a branch, implements the minimal fix, runs targeted tests, commits with a structured message, and opens a PR. Use it for bugs that need to ship immediately without going through the full plan-loop cycle.

See [/massu-hotfix](/docs/commands/massu-hotfix) for full documentation.

## Quality & Security

14 analysis commands for code quality and security. None of these edit source code.

### `/massu-review`

Automated code review across 7 dimensions: correctness, security, performance, maintainability, test coverage, API design, and rule compliance. It produces structured findings with severity levels and specific line references. Use it before requesting human review or as a pre-merge check.

See [/massu-review](/docs/commands/massu-review) for full documentation.

### `/massu-security-scan`

Deep security audit covering OWASP Top 10, API endpoint exposure, Row Level Security policy gaps, and secret detection. It goes beyond pattern matching to reason about authentication flows and data access paths. Use it when adding new API routes, modifying auth logic, or preparing for a security review.

See [/massu-security-scan](/docs/commands/massu-security-scan) for full documentation.

### `/massu-audit-deps`

Dependency audit covering known vulnerabilities (via npm audit), license compatibility, and unused packages. It surfaces transitive vulnerabilities and flags licenses that may conflict with your project's requirements. Use it before releases or when adding new dependencies.

See [/massu-audit-deps](/docs/commands/massu-audit-deps) for full documentation.

### `/massu-website-check`

Website-specific verification for Next.js and Supabase projects. Checks build output, environment variable completeness, Supabase RLS policy coverage, edge function compatibility, and route correctness. Use it before deploying a Next.js application.

See [/massu-website-check](/docs/commands/massu-website-check) for full documentation.

### `/massu-perf`

Performance analysis covering bundle size, lazy-loading opportunities, query efficiency, and edge function cold-start impact. Produces actionable findings ranked by estimated user impact. Use it when optimizing load times or investigating performance regressions.

See [/massu-perf](/docs/commands/massu-perf) for full documentation.

### `/massu-api-contract`

MCP tool contract verification. It audits every registered tool for schema correctness, input validation coverage, error handling completeness, and consistency between the tool definition and its handler implementation. Use it after adding or modifying MCP tools to catch contract mismatches before they reach production.

See [/massu-api-contract](/docs/commands/massu-api-contract) for full documentation.

### `/massu-codebase-audit`

Multi-phase codebase audit covering patterns, security, types, and tests in a single structured pass. It checks for pattern compliance violations, security anti-patterns, type safety gaps, and test coverage holes -- producing a consolidated report with severity-ranked findings. Use it as a comprehensive health check before a major release or after a large merge.

See [/massu-codebase-audit](/docs/commands/massu-codebase-audit) for full documentation.

### `/massu-config-audit`

Config validation and config-code alignment audit. It verifies that `massu.config.yaml` parses correctly, that all config keys referenced in code exist in the config file, and that no config values are hardcoded in source instead of using `getConfig()`. Use it after modifying the config schema or when config-related errors appear at runtime.

See [/massu-config-audit](/docs/commands/massu-config-audit) for full documentation.

### `/massu-import-audit`

Import chain audit for circular dependencies, ESM violations, and unused imports. It traces the full import graph, identifies cycles, flags CommonJS require() calls in ESM modules, and reports imports that are never used. Use it when build times increase unexpectedly or when module resolution errors appear.

See [/massu-import-audit](/docs/commands/massu-import-audit) for full documentation.

### `/massu-learning-audit`

Auto-learning effectiveness validation. It audits the observations, patterns, and rules that Massu AI has learned during sessions to verify they are accurate, non-contradictory, and actually being applied. Use it periodically to ensure the learning system is improving quality rather than accumulating stale or incorrect knowledge.

See [/massu-learning-audit](/docs/commands/massu-learning-audit) for full documentation.

### `/massu-push-light`

Fast pre-push verification that completes in approximately 90 seconds. It runs the most critical subset of verification checks -- type safety, tests, and build -- without the full security scan and dependency audit. Use it for low-risk pushes where speed matters and a full `/massu-push` is not warranted.

See [/massu-push-light](/docs/commands/massu-push-light) for full documentation.

### `/massu-type-audit`

Type mismatch audit across module boundaries. It identifies cases where function signatures, exported types, and interface implementations disagree -- especially at the seams between modules where TypeScript's type inference may not catch mismatches. Use it when refactoring shared types or after changing function signatures that cross module boundaries.

See [/massu-type-audit](/docs/commands/massu-type-audit) for full documentation.

### `/massu-verify`

Runs all VR-* verification checks with proof output. It executes every verification requirement defined in the canonical rules -- VR-FILE, VR-GREP, VR-BUILD, VR-TYPE, VR-TEST, VR-NEGATIVE, and all others -- and produces a structured pass/fail report with the actual command output as evidence. Use it as a comprehensive verification gate or to audit the current state of all verification requirements.

See [/massu-verify](/docs/commands/massu-verify) for full documentation.

### `/massu-checkpoint`

Checkpoint audit for the current implementation phase. It runs a 15-step verification sequence that checks plan coverage, deliverable completion status, verification evidence, and remaining work items. Use it mid-implementation to get a structured progress report and catch items that have been missed or only partially completed.

See [/massu-checkpoint](/docs/commands/massu-checkpoint) for full documentation.

## Release & Ops

Four commands for release preparation and operational tasks.

### `/massu-release`

Release preparation with full verification. It runs the complete verification suite, generates a changelog diff, checks that all planned items are complete, and prepares the release artifacts. Use it as the final gate before tagging a release.

See [/massu-release](/docs/commands/massu-release) for full documentation.

### `/massu-changelog`

Generates a structured changelog from git commits grouped by type (features, fixes, breaking changes). Writes to `CHANGELOG.md` only -- no source code changes. Use it as part of the release workflow or to update the changelog after a sprint.

See [/massu-changelog](/docs/commands/massu-changelog) for full documentation.

### `/massu-migrate`

Database migration management -- creates, validates, and tracks schema migrations. It checks migration files for destructive operations, verifies rollback paths exist, and ensures migrations are applied in order. Use it whenever the database schema changes.

See [/massu-migrate](/docs/commands/massu-migrate) for full documentation.

### `/massu-sync-public`

Syncs the internal repository to the public repository after passing all quality gates. It verifies that the codebase is clean, runs the full verification suite, strips internal-only content, and pushes to the public remote. Use it after a release or when internal changes are ready for public consumption.

See [/massu-sync-public](/docs/commands/massu-sync-public) for full documentation.

## Diagnostics

Five read-only diagnostic commands for project health visibility.

### `/massu-status`

A read-only project health dashboard that runs 14 checks across type safety, tests, build, security, dependencies, feature registry health, and recent audit activity. Produces a structured report with pass/fail status per check. Use it at the start of a session to understand the current state of the project.

See [/massu-status](/docs/commands/massu-status) for full documentation.

### `/massu-feature-parity`

Compares feature coverage across portals or environments to identify gaps. Reports which features are present in one context but missing from another. Use it when working on multi-portal applications where feature consistency is a requirement.

See [/massu-feature-parity](/docs/commands/massu-feature-parity) for full documentation.

### `/massu-gap-analyzer`

Post-implementation gap analysis. It compares the original plan against the actual implementation to identify deliverables that were missed, partially completed, or implemented differently than specified. Use it after `/massu-loop` completes to catch anything that slipped through the verification process.

See [/massu-gap-analyzer](/docs/commands/massu-gap-analyzer) for full documentation.

### `/massu-incident`

Incident post-mortem with prevention pipeline. It structures the investigation of a production incident -- timeline, root cause, contributing factors, and corrective actions -- and feeds the findings back into Massu AI's learning system so that similar issues are caught by future verification checks.

See [/massu-incident](/docs/commands/massu-incident) for full documentation.

### `/massu-session-optimization`

Session context optimization. It analyzes the current session's context usage -- loaded files, tool call history, and memory consumption -- and identifies opportunities to reduce overhead. Use it when sessions become slow or when context window limits are being approached.

See [/massu-session-optimization](/docs/commands/massu-session-optimization) for full documentation.

## Productivity

Five commands for codebase hygiene, documentation generation, pattern management, and effort estimation.

### `/massu-cleanup`

Systematically removes dead code -- unused imports, dead exports, orphaned files, and stale references. Performs blast radius analysis before every removal and verifies with negative grep after. Use it before a release or when the codebase has accumulated cruft from iterative development.

See [/massu-cleanup](/docs/commands/massu-cleanup) for full documentation.

### `/massu-doc-gen`

Generates JSDoc comments, README sections, and API reference documentation for undocumented exports. Analyzes function signatures and usage patterns to produce accurate descriptions. Use it to bootstrap documentation coverage or to keep API docs current before a release.

See [/massu-doc-gen](/docs/commands/massu-doc-gen) for full documentation.

### `/massu-onboard`

Generates a comprehensive onboarding guide for new team members by analyzing your codebase structure, coding conventions, team knowledge base, and known pitfalls. Writes to `docs/ONBOARDING.md`. Use it after major architectural changes or when onboarding a new contributor.

See [/massu-onboard](/docs/commands/massu-onboard) for full documentation.

### `/massu-new-pattern`

Creates and saves new development patterns with CLAUDE.md integration. It captures a pattern you have identified -- naming convention, file structure, registration step, or verification requirement -- and adds it to the project's pattern library so that future sessions apply it automatically. Use it whenever you discover a recurring convention that should be codified.

See [/massu-new-pattern](/docs/commands/massu-new-pattern) for full documentation.

### `/massu-estimate`

Effort estimation with complexity scoring and historical comparison. Analyzes a task description or plan file to estimate hours or story points based on codebase impact, novelty, risk, and similar past tasks stored in memory. Use it before starting a task to surface scope disagreements early.

See [/massu-estimate](/docs/commands/massu-estimate) for full documentation.

## Insights

Three read-only commands for retrospectives, planning, and measurement.

### `/massu-retrospective`

Generates a structured retrospective from Massu AI's session data -- quality metrics, cost summary, key decisions, failed attempts, and rule violations -- with actionable improvement items. Use it at the end of a sprint to prepare for team retrospective meetings.

See [/massu-retrospective](/docs/commands/massu-retrospective) for full documentation.

### `/massu-accessibility`

Static accessibility audit against WCAG 2.1 AA criteria: ARIA attributes, keyboard navigation, color contrast, semantic HTML, form labels, and image alt text. Produces severity-ranked findings without running a browser. Use it as part of your pre-release checklist.

See [/massu-accessibility](/docs/commands/massu-accessibility) for full documentation.

### `/massu-benchmark`

Performance benchmarking with baseline capture and regression detection. Tracks bundle size, test suite duration, TypeScript compilation time, build time, and hook execution times. Identifies which recent change caused a regression. Use it after adding dependencies or before a performance-sensitive release.

See [/massu-benchmark](/docs/commands/massu-benchmark) for full documentation.

## Command Decision Tree

Not sure which command to use? Start here:

- **Starting new work** -- `/massu-create-plan` then `/massu-plan` then `/massu-loop`
- **Scaffolding a feature** -- `/massu-new-feature`
- **Ready to commit** -- `/massu-commit`
- **Ready to push** -- `/massu-push` (full) or `/massu-push-light` (fast ~90s)
- **Tests are failing** -- `/massu-test`
- **Bug to diagnose** -- `/massu-debug`
- **Urgent production fix** -- `/massu-hotfix`
- **Restructuring code** -- `/massu-refactor`
- **Replacing a module** -- `/massu-rebuild`
- **Reverting changes** -- `/massu-rollback`
- **Before a code review** -- `/massu-review`
- **Security concerns** -- `/massu-security-scan`
- **Full codebase audit** -- `/massu-codebase-audit`
- **MCP tool contracts** -- `/massu-api-contract`
- **Type safety check** -- `/massu-type-audit`
- **Config correctness** -- `/massu-config-audit`
- **Import health** -- `/massu-import-audit`
- **Cutting a release** -- `/massu-release` (runs `/massu-changelog` internally)
- **Schema changes** -- `/massu-migrate`
- **Sync to public repo** -- `/massu-sync-public`
- **Project health check** -- `/massu-status`
- **Performance problems** -- `/massu-perf`
- **Dependency concerns** -- `/massu-audit-deps`
- **Deploying a website** -- `/massu-website-check`
- **Dead code / cleanup** -- `/massu-cleanup`
- **Generate documentation** -- `/massu-doc-gen`
- **Onboarding new member** -- `/massu-onboard`
- **Create a new pattern** -- `/massu-new-pattern`
- **Effort estimation** -- `/massu-estimate`
- **Session retrospective** -- `/massu-retrospective`
- **Accessibility check** -- `/massu-accessibility`
- **Benchmark performance** -- `/massu-benchmark`
- **Post-implementation gaps** -- `/massu-gap-analyzer`
- **Incident post-mortem** -- `/massu-incident`
- **Learning system health** -- `/massu-learning-audit`
- **Session context bloat** -- `/massu-session-optimization`
- **Verification checkpoint** -- `/massu-checkpoint`
- **Run all VR checks** -- `/massu-verify`

## Tips

- Always run `/massu-plan` after `/massu-create-plan` -- the audit step catches gaps that are invisible when you wrote the plan yourself.
- `/massu-commit` and `/massu-push` are gates, not formalities. If they block, fix the issue rather than working around it.
- `/massu-status` at the start of each session takes 30 seconds and prevents surprises mid-implementation.
- The Implementation Workflow commands do not edit source code until `/massu-loop`. If you need to rethink the plan, do it before you reach the loop.
- `/massu-hotfix` is for genuine emergencies. For anything that can wait an hour, use the full plan-loop-commit-push pipeline.
- Use `/massu-push-light` for low-risk pushes when the full `/massu-push` suite is not warranted -- it runs in about 90 seconds.
- `/massu-rebuild` enforces feature parity before deleting the old module. Never delete first and rebuild second.
- Run `/massu-checkpoint` mid-implementation to catch missed deliverables before you reach the commit stage.
