---
title: "Advanced Commands"
description: "Guide to debugging, refactoring, security scanning, and performance analysis commands"
---

# Advanced Commands

Massu AI includes 26 workflow commands. While the [core implementation workflow](/docs/commands) (create-plan, plan, loop, commit, push) handles most development tasks, the additional commands provide specialized tools for testing, debugging, security, and operations.

## When to Use Which Command

Use this decision tree to pick the right command:

### I need to fix something

- **Quick bug fix (1-3 files)?** Use `/massu-hotfix` — creates a branch, applies fix, runs verification, creates PR
- **Complex bug?** Use `/massu-debug` — 9-step hypothesis-driven debugging with root cause tracing
- **Failing tests?** Use `/massu-test --fix` — analyzes failures and applies fixes

### I need to change code structure

- **Small refactor (<20 files)?** Use `/massu-refactor` — incremental transforms with behavioral equivalence
- **Large refactor (>20 files)?** Use `/massu-create-plan` — full plan-audit-implement cycle

### I need to check code quality

- **Quick code review?** Use `/massu-review` — 7-dimension automated review
- **Security audit?** Use `/massu-security-scan` — deep OWASP/RLS/secrets scan
- **Performance check?** Use `/massu-perf` — bundle size, queries, edge functions
- **Dependency health?** Use `/massu-audit-deps` — vulnerabilities, licenses, unused deps
- **Website health?** Use `/massu-website-check` — Next.js, Supabase, TypeScript verification

### I need to ship

- **Prepare release?** Use `/massu-release` — version bump, changelog, verification, tagging
- **Generate changelog?** Use `/massu-changelog` — conventional commit parsing
- **Database changes?** Use `/massu-migrate` — migration creation, RLS verification, rollback

## Bootstrapping Test Coverage with /massu-test

The test command's `--generate` mode is useful for bootstrapping tests for untested modules:

```
/massu-test --generate analytics
```

This will:
1. Analyze the module's exports and public API
2. Generate test cases covering happy paths and edge cases
3. Create the test file in `__tests__/`
4. Run the generated tests to verify they pass

Combine with `--coverage` to find all untested modules first:

```
/massu-test --coverage
```

## Debugging Workflow with /massu-debug

The debug command follows a 9-step protocol:

1. **Symptom Capture** — What is the exact error? Where does it occur?
2. **Locate Error** — Find the exact file and line
3. **Trace Call Chain** — Follow the execution path backward
4. **Hypothesis Formation** — Form 2-3 testable hypotheses
5. **Hypothesis Testing** — Test each hypothesis systematically
6. **Root Cause** — Identify the actual root cause
7. **Fix Implementation** — Apply the minimal fix
8. **Verification** — Prove the fix works (tests pass, error gone)
9. **Learning Record** — Document what was learned for future reference

This prevents the common pattern of guessing and applying random fixes.

## Refactoring Safely with /massu-refactor

The refactor command enforces safety through:

- **Scope Guard** — Aborts if the refactor would touch more than 20 files
- **Baseline Snapshot** — Captures the current test state before any changes
- **Blast Radius Analysis** — Uses CR-10 to identify all references to changed values
- **Incremental Batches** — Changes at most 3 files per batch, verifying after each
- **Behavioral Equivalence** — Tests must pass with identical results after refactoring
- **Negative Verification** — Old patterns must return 0 grep matches after removal

## Security Scanning with /massu-security-scan

The security scan covers 7 dimensions:

| Dimension | What It Checks | Example Findings |
|-----------|---------------|-----------------|
| OWASP Top 10 | XSS, injection, SSRF, open redirect | `innerHTML` usage, template literal SQL |
| API Security | Authentication on all endpoints | Missing `createServerSupabaseClient` call |
| Supabase RLS | Row-level security on all tables | `CREATE TABLE` without `ENABLE ROW LEVEL SECURITY` |
| Secret Scanning | Hardcoded credentials in source | API keys, passwords in code |
| Security Headers | HTTP security headers | Missing CSP, HSTS, X-Frame-Options |
| Dependencies | Known vulnerabilities | CVEs from OSV.dev database |
| Webhook Security | HMAC verification on webhook handlers | Missing signature validation |

## Performance Analysis with /massu-perf

The performance command runs 6 read-only checks:

1. **Bundle Size** — Flags routes with first-load JS > 150KB
2. **Loading States** — Checks for Suspense boundaries and loading.tsx files
3. **Query Patterns** — Detects N+1 queries and unbounded `.select('*')` calls
4. **Edge Functions** — Checks Supabase edge function sizes
5. **Image Optimization** — Verifies Next.js Image component usage
6. **MCP Server** — Checks tool handler performance patterns

## Database Migrations with /massu-migrate

The migrate command has 3 modes:

- **`/massu-migrate create [name]`** — Generates a new migration with RLS, indexes, and rollback SQL
- **`/massu-migrate validate`** — Validates all existing migrations (ordering, RLS, types)
- **`/massu-migrate check`** — Quick health check (runs `scripts/massu-migration-validator.sh`)

Every migration is verified for:
- Sequential numbering (no gaps)
- RLS enabled on all tables
- Type sync with TypeScript interfaces
- Rollback SQL generation

## Release Process with /massu-release

The release command runs 6 steps:

1. **Version Determination** — Analyzes commit history for major/minor/patch
2. **Pre-Release Verification** — 4 tiers: types, tests, patterns, security
3. **Changelog Generation** — From conventional commits since last tag
4. **Version Bump** — Updates package.json
5. **Release Notes** — Generates formatted release notes
6. **Commit + Tag** — Creates release commit and git tag (does NOT push)

After `/massu-release`, use `/massu-push` to push the release with full verification.
